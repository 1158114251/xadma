/**************************************************************************

    AVStream Simulated Hardware Sample

    Copyright (c) 2001, Microsoft Corporation.

    File:

        hwsim.cpp

    Abstract:
        
        This file is the hardware simulation header.  

        The simulation fakes "DMA" transfers, scatter gather mapping handling, 
        ISR's, etc...  The ISR routine in here will be called when an ISR 
        would be generated by the fake hardware and it will directly call into 
        the device level ISR for more accurate simulation.

    History:

        created 3/9/2001

**************************************************************************/

#define ADMA_MAX_DESCRIPTOR_NUM	(128UL)
#define ADMA_DESCRIPTOR_OFFSET	(0x200)
#define ADMA_ONE_DESCRIPTOR_MAX_TRANS_SIZE (1024UL * 1024UL - 4UL)
#define ADMA_MAX_TRANSFER_SIZE  (ADMA_MAX_DESCRIPTOR_NUM * PAGE_SIZE)//(ADMA_MAX_DESCRIPTOR_NUM * ADMA_ONE_DESCRIPTOR_MAX_TRANS_SIZE)
#define ADMA_RD_DTS_ADDR		(0x80000000UL)
#define ADMA_WR_DTS_ADDR		(0x80002000UL)
#define ADMA_DIR_REG_OFFSET		(0x100)

#define FRAME_BUFFER_NUM			5
#define FRAME_BUFFER_REG_ADDR(x)	(0x5000 + x * 0x20)

#pragma pack(1)

/// H2C/C2H SGDMA Registers (H2C: 0x0, C2H:0x100)
typedef struct {
	UINT32 rcStatusDescLo;//0x00
	UINT32 rcStatusDescHi;
	UINT32 epDescFifoLo;
	UINT32 epDescFifoHi;
	UINT32 dmaLastPtr;
	UINT32 tableSize;
	UINT32 control;
	UINT32 reserved1[57];//0xFC
} ADMA_SGDMA_REGS, *PADMA_SGDMA_REGS;

/// \brief Descriptor for a single contiguous memory block transfer.
///
/// Multiple descriptors are linked a 'next' pointer. An additional extra adjacent number gives the 
/// amount of subsequent contiguous descriptors. The descriptors are in root complex memory, and the
/// bytes in the 32-bit words must be in little-endian byte ordering.
typedef struct adma_descriptor_t {//offset 0x200 from RC Read Descriptor Base or RC Write Descriptor Base registers
	UINT32 srcAddrLo; // source address (low 32-bit)
	UINT32 srcAddrHi; // source address (high 32-bit)
	UINT32 dstAddrLo; // destination address (low 32-bit)
	UINT32 dstAddrHi; // destination address (high 32-bit)
					  // next descriptor in the single-linked list of descriptors, 
					  // this is the bus address of the next descriptor in the root complex memory.
	UINT32 control;
	UINT32 reserved[3];//padding total 32bytes
} ADMA_DESCRIPTOR, *PADMA_DESCRIPTOR;

/// Result buffer of the streaming DMA operation. 
/// The ADMA IP core writes the result of the DMA transfer to the host memory
typedef struct {//start from RC Read Descriptor Base or RC Write Descriptor Base registers
	UINT32 status[ADMA_MAX_DESCRIPTOR_NUM];
} ADMA_RESULT, *PADMA_RESULT;

/// Altera VIP Frame Buffer II IP Registers
typedef struct {
	UINT32 control;//0x00
	UINT32 status;
	UINT32 interrupt;
	UINT32 frameCount;
	UINT32 dropRepeatCount;
	UINT32 frameInfo;
	UINT32 frameStartAddr;
	UINT32 frameReader;//0xFC
	UINT32 misc;
	UINT32 lockEn;
	UINT32 inputFrameRate;
	UINT32 outputFrameRate;
} FRAME_BUFFER_REGS, *PFRAME_BUFFER_REGS;

#pragma pack()

//
// SCATTER_GATHER_MAPPINGS_MAX:
//
// The maximum number of entries in the hardware's scatter/gather list.  I
// am making this so large for a few reasons:
//
//     1) we're faking this with uncompressed surfaces -- 
//            these are large buffers which will map to a lot of s/g entries
//     2) the fake hardware implementation requires at least one frame's
//            worth of s/g entries to generate a frame
//
#define SCATTER_GATHER_MAPPINGS_MAX 128

//
// SCATTER_GATHER_ENTRY:
//
// This structure is used to keep the scatter gather table for the fake
// hardware as a doubly linked list.
//
typedef struct _SCATTER_GATHER_ENTRY {

    LIST_ENTRY ListEntry;
    PKSSTREAM_POINTER CloneEntry;
    PUCHAR Virtual;
    ULONG ByteCount;

} SCATTER_GATHER_ENTRY, *PSCATTER_GATHER_ENTRY;

//
// CHardwareSimulation:
//
// The hardware simulation class.
//
class CHardwareSimulation {

private:

    //
    // The image synthesizer.  This is a piece of code which actually draws
    // the requested images.
    //
    CImageSynthesizer *m_ImageSynth;

    //
    // The synthesis buffer.  This is a private buffer we use to generate the
    // capture image in.  The fake "scatter / gather" mappings are filled
    // in from this buffer during each interrupt.
    //
    PUCHAR m_SynthesisBuffer;

    //
    // Key information regarding the frames we generate.
    //
    LONGLONG m_TimePerFrame;
    ULONG m_Width;
    ULONG m_Height;
    ULONG m_ImageSize;

    //
    // Scatter gather mappings for the simulated hardware.
    //
    KSPIN_LOCK m_ListLock;
    LIST_ENTRY m_ScatterGatherMappings;

    //
    // Lookaside for memory for the scatter / gather entries on the scatter /
    // gather list.
    //
    NPAGED_LOOKASIDE_LIST m_ScatterGatherLookaside;

    //
    // The current state of the fake hardware.
    //
    HARDWARE_STATE m_HardwareState;

    //
    // The pause / stop hardware flag and event.
    //
    BOOLEAN m_StopHardware;
    KEVENT m_HardwareEvent;

    //
    // Maximum number of scatter / gather mappins in the s/g table of the
    // fake hardware.
    //
    ULONG m_ScatterGatherMappingsMax;

    //
    // Number of scatter / gather mappings that have been completed (total)
    // since the start of the hardware or any reset.
    //
    ULONG m_NumMappingsCompleted;

    //
    // Number of scatter / gather mappings that are queued for this hardware.
    //
    ULONG m_ScatterGatherMappingsQueued;
    ULONG m_ScatterGatherBytesQueued;

    //
    // Number of frames skipped due to lack of scatter / gather mappings.
    //
    ULONG m_NumFramesSkipped;

    //
    // The "Interrupt Time".  Number of "fake" interrupts that have occurred
    // since the hardware was started.
    // 
    ULONG m_InterruptTime;

    //
    // The system time at start.
    //
    LARGE_INTEGER m_StartTime;
    
    //
    // The DPC used to "fake" ISR
    //
    KDPC m_IsrFakeDpc;
    KTIMER m_IsrTimer;

    //
    // The hardware sink that will be used for interrupt notifications.
    //
    IHardwareSink *m_HardwareSink;

    //
    // FillScatterGatherBuffers():
    //
    // This is called by the hardware simulation to fill a series of scatter /
    // gather buffers with synthesized data.
    //
    NTSTATUS
    FillScatterGatherBuffers (
        );

public:

	PADMA_SGDMA_REGS m_AdmaRdSgdmaReg;
	PADMA_SGDMA_REGS m_AdmaWrSgdmaReg;
	PADMA_DESCRIPTOR m_AdmaRdDescriptor;
	PADMA_DESCRIPTOR m_AdmaWrDescriptor;
	PADMA_RESULT m_AdmaRdResult;
	PADMA_RESULT m_AdmaWrResult;
	PFRAME_BUFFER_REGS m_FrameBufferReg[FRAME_BUFFER_NUM];

    LONG GetSkippedFrameCount()
    {
        return InterlockedExchange((LONG*)&this->m_NumFramesSkipped, this->m_NumFramesSkipped);
    }
    //
    // CHardwareSimulation():
    //
    // The hardware simulation constructor.  Since the new operator will
    // have zeroed the memory, only initialize non-NULL, non-0 fields. 
    //
    CHardwareSimulation (
        IN IHardwareSink *HardwareSink
        );

    //
    // ~CHardwareSimulation():
    //
    // The hardware simulation destructor.
    //
    ~CHardwareSimulation (
        )
    {
    }

    //
    // Cleanup():
    //
    // This is the free callback for the bagged hardware sim.  Not providing
    // one will call ExFreePool, which is not what we want for a constructed
    // C++ object.  This simply deletes the simulation.
    //
    static
    void
    Cleanup (
        IN CHardwareSimulation *HwSim
        )
    {
        delete HwSim;
    }

    //
    // FakeHardware():
    //
    // Called from the simulated interrupt.  First we fake the hardware's
    // actions (at DPC) then we call the "Interrupt service routine" on
    // the hardware sink.
    //
    void
    FakeHardware (
        );

    //
    // Start():
    //
    // "Start" the fake hardware.  This will start issuing interrupts and 
    // DPC's. 
    //
    // The frame rate, image size, and a synthesizer must be provided.
    //
    NTSTATUS
    Start (
        CImageSynthesizer *ImageSynth,
        IN LONGLONG TimePerFrame,
        IN ULONG Width,
        IN ULONG Height,
        IN ULONG ImageSize
        );

    //
    // Pause():
    //
    // "Pause" or "unpause" the fake hardware.  This will stop issuing 
    // interrupts or DPC's on a pause and restart them on an unpause.  Note
    // that this will not reset counters as a Stop() would.
    //
    NTSTATUS
    Pause (
        IN BOOLEAN Pausing
        );

    //
    // Stop():
    //
    // "Stop" the fake hardware.  This will stop issuing interrupts and
    // DPC's.
    //
    NTSTATUS
    Stop (
        );

    //
    // ProgramScatterGatherMappings():
    //
    // Program a series of scatter gather mappings into the fake hardware.
    //
    ULONG
    ProgramScatterGatherMappings (
        IN PKSSTREAM_POINTER Clone,
        IN PUCHAR *Buffer,
        IN PKSMAPPING Mappings,
        IN ULONG MappingsCount,
        IN ULONG MappingStride
        );

    //
    // Initialize():
    //
    // Initialize a piece of simulated hardware.
    //
    static 
    CHardwareSimulation *
    Initialize (
        IN KSOBJECT_BAG Bag,
        IN IHardwareSink *HardwareSink
        );

    //
    // ReadNumberOfMappingsCompleted():
    //
    // Read the number of mappings completed since the last hardware reset.
    //
    ULONG
    ReadNumberOfMappingsCompleted (
        );

};

